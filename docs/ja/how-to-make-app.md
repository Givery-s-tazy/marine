# Application問題の作り方
## 概要
Application問題とは受講者が作成したWebアプリケーションを実行・評価するための枠組みです。  
著名なWebアプリケーションのフレームワークとしては

- Ruby on Rails(Ruby)
- Express(NodeJS)
- Spring(Java)

などがありますが、Application問題を作成することで受講者が自分のローカル環境で作成したWebApplicationを実行評価することができます。

## 受講者がApplication問題に回答する流れ
Application問題を開くと画面左に問題文が表示されます。
受講者のやるべきことは自分のローカル環境でその要件を満足するWebApplicationを作成することです。

作成すべきWebApplicationのスケルトン(初期ファイルセット)は画面上よりzipダウンロードできるのでそれを展開してそこから開発をスタートしてください。

問題を解くためにはJavaやNodeJS、dockerなどのツールが受講者側の環境に必要な場合があります。
それらのツールは受講者側で適宜用意してください。

解答作成後はそのファイル一式をzipにして画面上よりアップロードします。

ファイルをアップロードすると作成したWebアプリケーションがtrackの環境上で起動され、また出題者が用意したテストが実行されます。

そこで受講者は

- 作成したWebアプリケーションが意図したとおりにtrack環境で動作しているか？
- 作成したWebアプリケーションが出題者の用意したテストを満たしているか？

を確認することができます。

## Application問題の画面構成
Application問題の画面は大きく以下の4つのエリアに分かれています。

- 画面左エリア
- 画面右上エリア
- 画面右下エリア
- フッター

以下にそれぞれのエリアの内容を説明します。

### 画面左エリア
ここには問題文が表示されます。

またエリア右上のメニューをクリックすることでファイルツリーを表示することができます。

ファイルツリーにはユーザがアップロードしたzipに含まれるファイルが表示され、選択したファイルが画面右上エリアで確認できます。

### 画面右上エリア
ファイルツリーで選択したファイルを表示する画面です。

ユーザが編集したファイルは初期状態(または直前のupload)との差分で表示されます。

### 画面右下エリア
このエリアには

- ステータス
- テストケース
- ログ

3つのタブがありそれぞれ以下の内容が表示されます

#### ステータス
ユーザが作成したWebアプリケーションの起動状態を表示します。

Webアプリケーションが起動している状態の場合はブラウザを含む任意のHttpClientからそれにアクセス可能です。

#### テストケース
最新のアップロードzipにおけるテストの実行結果が表示されます。

アップロードからテストの実行完了までには数分かかります。

#### ログ
最後に起動したWebアプリケーションのログが表示されます。

### フッター
フッターには以下の3つのボタンがあります

- 起動/停止: アップロードされた最新のzipでtrack環境でWebアプリケーションを起動/停止します。
- アップロード: zipファイルをアップロードします。
- ダウンロード: 初期ファイルセットをダウンロードします。

## Marineを使用したApplication問題の作成
Application問題は作成したWebアプリケーションをtrack環境で実行する都合上、一部AWSのAPIにアクセスする必要があります。

このため作成のために必要なフル機能を使用するためにはAWSのアクセスキーが必要です。

具体的にはMarineを起動するdocker-compose.ymlに以下の環境変数定義が必要になります。

```
  environment:
    AWS_ACCESS_KEY_ID: xxxx
    AWS_SECRET_ACCESS_KEY: xxxx
```

アクセスキーが必要な場合はGivery管理者までお問い合わせください。

ただし、アクセスキーがなくとも

- 作成した定義ファイル(application.yml)のValidation
- 画面上でのREADME.mdの確認
- 作成した初期ファイルセットおよびソリューションの画面上での確認

は行なえます。
作成したWebアプリケーションの実行及びテストをローカル環境で確認するのであればアクセスキーがなくともある程度の作成を行うことは可能です。

具体的にアクセスキーがないとできない操作は以下のとおりです。

- 作成したWebアプリケーションのtrack環境への登録
- テスト実行
- zipアップロード
- 作成したWebアプリケーションのtrack環境での起動/停止

## Application問題作成の流れ
Application問題の作成時に作成者がやらなければならない作業は以下のとおりです。

- 設定ファイル(application.yml)の作成
- 問題文(README.md)の記述
- 受講者にダウンロードさせる初期ファイルセット(appディレクトリ)の作成
- 解答例(solutionディレクトリ)の作成
- 起動/テストスクリプトの作成
- テストの出力がTAP形式でない場合の変換scriptの作成

以下にそれぞれの作業について説明します。

### 設定ファイル(application.yml)の作成
application.ymlはApplication問題専用の設定ファイルです。
(challengeにおけるtrack.ymlのようなものです。)

このファイルでは以下のキーを指定できます。

- `type`: `web`固定。省略可
- `test`: RUNで使用するコマンド。必須。通常はhiddenディレクトリに`run.sh`を用意した上で`sh run.sh`を指定します。
- `images`: READMEから参照する画像。複数指定可
- `infra`: 実行環境(ECS)のサイズ指定。任意
  - `cpu`: `256 x N`の値で指定。省略時は256
  - `memory`: `512 x N`の値で指定。省略時は512
- `conversion`: conversionの指定。省略時は`cat application.log`となる
  - `command`: 実行コマンド。複数可
  - `envConf`: orca環境定義(track.ymlと同様)
  - ファイルセットの指定はconversionディレクトリの内容がそのまま使われるので不要
- `testCount`:  テストケース数。CompilerOptionで必須/任意が変わる
- `required`: uploadするzipに必ず含まれていなければならないファイル名。複数可
- `services`: サービス定義。必須。ここ以下はdocker-compose.yml互換
  - 有効な定義: `image`, `user`, `ports`, `environment`, `healthcheck`, `depends_on`, `ports`, `working_dir`, `command`
  - 上記のそれぞれの定義は[docker-compose.ymlのreference](https://docs.docker.com/compose/compose-file/compose-file-v3/)を参照のこと
  - サービスが一つの場合はそれがMainService。複数ある場合は名前が`app`または`web`のものがManinServiceとなる
  - MainServiceではcommandが必須(UPで使用)。通常はhiddenディレクトリに`up.sh`を用意した上で`sh up.sh`を指定します。
  - 複数サービスが有る場合はMainServiceに値として`127.0.0.1`を持つ環境変数が必須(詳細は後述のHOST_NAMEの話を参照)
  - imageにはECR上のイメージを指定することが望ましい。(後述)
  - healthcheckは任意だが起動に時間がかかる場合は定義した方が良い。

`test`や`conversion`での指定内容については後述します。

### 問題文(README.md)の記述
README.mdには問題の内容をマークダウンで記述します。
フォーマットは任意ですが、オフィシャル問題の場合はある程度テンプレート化されているのでテンプレートに従って記述するようにしてください。

マークダウンの記述ではいくつかの[拡張機能](markdown-extension.md)が使用できます。

### 受講者にダウンロードさせる初期ファイルセット(appディレクトリ)の作成
appディレクトリには受講者にダウンロードさせる初期のファイルセットを置きます。

appディレクトリ以下のディレクトリ構造は自由です。

appディレクトリ内のどこかに`.gitignore`ファイルがある場合はその指定にマッチするファイルはダウンロードするファイルには含まれません。

例えばRuby on Railsの問題を作成する場合、このディレクトリにはRoRでgenerateした初期のスケルトンをまるごと配置します。

もちろん生成後に出題する問題に合わせていくつかのファイルを変更しても構いません。

ユーザの環境構築を容易にするためにdocker-compose.ymlをファイルセットに含めても構いませんが、その場合は後述の[HOST_NAMEの話](#HOST_NAMEの話)、[docker image名の話](#docker image名の話)に注意してください。

### 解答例(solutionディレクトリ)の作成
solutionディレクトリには作成するWebアプリケーションの回答例となるコードを置きます。

ここに配置するファイルはappディレクトリと差分のあるファイルだけで構いません。(track環境でsolutionプレビューを起動する場合はappディレクトリの内容にsolutionディレクトリの内容を上書きコピーした状態で起動します。)

### 起動/テストスクリプトの作成(hiddenディレクトリ)
hiddenディレクトリにはtrack環境で作成したWebアプリケーションを起動するためのスクリプト類を置きます。  
hiddenディレクトリの内容は受講者には配布されません。

通常はWebサーバを起動するためのup.shと、テスト実行のためのrun.shをここに置きます。
また、それらのスクリプトの先頭は以下の例のような環境変数`SUBMISSION_URL`からzipをダウンロードして展開する処理でなければなりません。

``` sh
wget -q -O temp.zip $SUBMISSION_URL
unzip -o temp.zip
rm temp.zip

echo Succeed to extract zip

## 以降にWebサーバを起動するコマンド、またはテスト実行のコマンドを記述する
```

厳密に言うとtrack環境でのアプリケーション実行時に初期状態で存在するファイルセットはこのhiddenディレクトリ内にあるファイルだけです。

環境変数`SUBMISSION_URL`には受講者のアップロードしたzipのURLが設定されているので、それをダウンロードしてから必要な処理を行います。

また、hiddenディレクトリには受講者から隠しておきたいファイル(例えばテスト用のファイル)を置いておいても構いません。

### テストの出力がTAP形式でない場合の変換script(conversinoディレクトリ)の作成
conversionディレクトリにはapplication.yml#testで指定したテストコマンドの実行結果をTAP形式に変換するスクリプトを配置します。

テストコマンドの出力が最初からTAP形式になっている場合はconversionは必要ありません。
使用するフレームワークによってはテスト出力をTAP形式にすることが難しい場合もあるので、その場合のみconversionを作成してください。

conversionの実行コマンドとconversionを実行するdockerイメージ名はapplication.yml#conversionで指定します。

## その他のトピック
### solution.md
問題の解法に対する解説を記述する場合はその内容をsolution.mdに記載してください。

このファイルはMarineおよびWebアプリケーション画面では使用されません。

### docker image名の話
application.ymlで定義するdocker image名でもdocker-hub上のイメージ名を指定することができますが、この場合docker-hubの「6時間内にpullできる回数は100回まで」という制限に引っかかる可能性があります。

pullは起動やテスト実行の度に発生するので、受講者の数が多い場合はここでの指定はECR経由でのimage名にする必要があります。(ECR経由でのimage名はGivery管理者に問い合わせてください。)

一方でappディレクトリにdocker-compose.ymlを配置する場合は、受講者のローカル環境からはECRにアクセスできないのでdocker-hub上にあるイメージ名を指定する必要があります。

### HOST_NAMEの話
docker-compose.ymlで `app`と`db`の２つのサービスが定義されている場合、app側では`db:5432`のように`<サービス名>:<ポート>`という形式でdbコンテナを参照できます。

しかし、trackでのアプリケーション実行環境であるECS(Fargate)ではこのようなエイリアスでの参照はできません。
Fargateで`app`コンテナからdbコンテナを参照する場合は`127.0.0.1:5432`のようにループバックアドレスを指定しなければなりません。(`localhost`もNG)

これを踏まえて、appコンテナからdbコンテナへの参照をlocalのdocker-composeでもFargateでも動作するようにする場合はホスト名の部分を環境変数から取得する必要があります。

これがapplication.yml#servicesのMainServiceで値が`127.0.0.1`の環境変数が必要な理由です。

appディレクトリにdocker-compose.ymlを含める場合も同じ環境変数を定義してメインコンテナからのアクセスはその環境変数を使用して行うようにREADME.mdで指示してください。

### 国際化対応
trackではチャレンジのコンパイル時にオプションとして言語(ja, en)を指定します。

このオプションによってREADMEを取り込む時のファイル選択のロジックが変わります。

- `ja` -> `README_ja.md`があればそれを使用、なければ`README.md`を使用
- `en` -> `README_en.md`があればそれを使用、なければ`README.md`を使用

同じやり方でsolution.mdも国際化対応が可能です。

国際化する問題の場合は日本語と英語の両方のREADMEを用意することが望まれます。

README.md, solution.md以外の部分には国際化対応のサポートはありません。
